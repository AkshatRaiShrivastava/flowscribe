import { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
  MiniMap,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  Position,
} from 'reactflow';
import 'reactflow/dist/style.css';

const nodeTypes = {
  start: ({ data }) => (
    <div className="px-4 py-2 shadow-lg rounded-lg border-2 border-blue-400 bg-blue-50">
      <div className="font-bold text-sm text-blue-900">{data.label}</div>
    </div>
  ),
  end: ({ data }) => (
    <div className="px-4 py-2 shadow-lg rounded-lg border-2 border-purple-400 bg-purple-50">
      <div className="font-bold text-sm text-purple-900">{data.label}</div>
    </div>
  ),
  process: ({ data }) => (
    <div className="px-4 py-2 shadow-lg rounded-md border-2 border-gray-300 bg-white">
      <div className="text-sm text-gray-700">{data.label}</div>
    </div>
  ),
  decision: ({ data }) => (
    <div className="px-4 py-2 shadow-lg rotate-45">
      <div className="px-4 py-2 border-2 border-amber-400 bg-amber-50 -rotate-45">
        <div className="text-sm text-amber-900">{data.label}</div>
      </div>
    </div>
  ),
};

const FlowchartDisplay = ({ flowchartCode }) => {
  const [error, setError] = useState(null);
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  const parseFlowchart = useCallback((code) => {
    if (!code) return { nodes: [], edges: [] };

    try {
      const lines = code
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('graph'));

      const nodes = [];
      const edges = [];
      let yOffset = 0;
      let lastNodeId = '';

      lines.forEach((line, index) => {
        const parts = line.split('-->');
        
        parts.forEach((part, partIndex) => {
          const nodeMatch = part.match(/([A-Z])\[(.*?)\]|([A-Z])\{(.*?)\}/);
          if (nodeMatch) {
            const id = nodeMatch[1] || nodeMatch[3];
            const label = nodeMatch[2] || nodeMatch[4];
            const isDecision = nodeMatch[4] !== undefined;

            // Only add node if it doesn't exist
            if (!nodes.find(n => n.id === id)) {
              let type = 'process';
              if (label.toLowerCase() === 'start') type = 'start';
              else if (label.toLowerCase() === 'end') type = 'end';
              else if (isDecision) type = 'decision';

              nodes.push({
                id,
                type,
                position: { x: 200 * partIndex, y: yOffset },
                data: { label },
                sourcePosition: Position.Right,
                targetPosition: Position.Left,
              });
            }

            // Create edge if there's a next part
            if (partIndex < parts.length - 1) {
              const nextPart = parts[partIndex + 1];
              const nextNodeMatch = nextPart.match(/([A-Z])/);
              if (nextNodeMatch) {
                const edgeLabel = nextPart.match(/\|(.*?)\|/)?.[1] || '';
                edges.push({
                  id: `${id}-${nextNodeMatch[1]}`,
                  source: id,
                  target: nextNodeMatch[1],
                  label: edgeLabel,
                  type: 'smoothstep',
                  animated: true,
                  style: { stroke: '#7BB2F0', strokeWidth: 2 },
                });
              }
            }

            lastNodeId = id;
          }
        });

        // Increment y-offset for next row if this line created a node
        if (lastNodeId) {
          yOffset += 100;
        }
      });

      return { nodes, edges };
    } catch (err) {
      console.error('Error parsing flowchart:', err);
      setError('Failed to parse flowchart syntax');
      return { nodes: [], edges: [] };
    }
  }, []);

  useEffect(() => {
    if (flowchartCode) {
      const { nodes: newNodes, edges: newEdges } = parseFlowchart(flowchartCode);
      setNodes(newNodes);
      setEdges(newEdges);
      setError(null);
    }
  }, [flowchartCode, parseFlowchart, setNodes, setEdges]);

  if (!flowchartCode) {
    return null;
  }

  return (
    <div className="bg-black/30 backdrop-blur-md rounded-xl border border-white/10 shadow-2xl">
      <div className="border-b border-white/10 p-4 flex items-center justify-between">
        <div className="flex items-center space-x-3">
          <span className={`h-4 w-4 rounded-full flex items-center justify-center ${
            error ? 'bg-red-500/20' : 'bg-violet-500/20'
          }`}>
            <span className={`h-2 w-2 rounded-full ${
              error ? 'bg-red-500' : 'bg-violet-500'
            }`}></span>
          </span>
          <h2 className="text-sm font-medium text-gray-400">Interactive Flowchart</h2>
        </div>
      </div>
      <div className="relative group">
        <div className="absolute inset-0 bg-gradient-to-r from-violet-500/10 to-indigo-500/10 rounded-b-xl opacity-50"></div>
        <div className="relative p-6">
          {error ? (
            <div className="flex items-center gap-3 text-red-400 bg-red-500/10 rounded-lg p-4 border border-red-500/20">
              <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>
              <p>{error}</p>
            </div>
          ) : (
            <div style={{ width: '100%', height: '500px' }}>
              <ReactFlow
                nodes={nodes}
                edges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                nodeTypes={nodeTypes}
                fitView
                className="bg-gray-50 rounded-lg"
              >
                <Background color="#94a3b8" gap={16} size={1} />
                <Controls />
                <MiniMap
                  nodeStrokeColor={(n) => {
                    if (n.type === 'start') return '#93c5fd';
                    if (n.type === 'end') return '#c084fc';
                    if (n.type === 'decision') return '#fcd34d';
                    return '#94a3b8';
                  }}
                  nodeColor={(n) => {
                    if (n.type === 'start') return '#dbeafe';
                    if (n.type === 'end') return '#f3e8ff';
                    if (n.type === 'decision') return '#fef3c7';
                    return '#ffffff';
                  }}
                />
              </ReactFlow>
            </div>
          )}
          {flowchartCode && !error && (
            <div className="mt-4 p-4 bg-black/40 rounded-lg border border-white/5">
              <pre className="text-xs text-gray-400 font-mono overflow-x-auto">
                {flowchartCode}
              </pre>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default FlowchartDisplay;
